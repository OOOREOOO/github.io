<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>

		创建一个构造函数，专门用来创建Person对象的
		构造函数就是一个普通的函数，创建方式和不同函数没有区别
		不同的是构造函数习惯上首字母大写

		<br>
		构造函数和普通函数的区别 就是调用方式的不同
		普通函数是直接调用，而构造函数需要使用new关键字来调用

		<br>

		构造函数执行的流程
		1.立即创建一个新的对象
		2.将新建的对象设置为函数中的this，在构造函数中可以使用this来引用新建的对象
		3.逐行执行函数中的代码
		4.将新建的对象作为返回值返回
		<br>

		使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类
		我们讲通过一个构造函数创建的对象，称为是该类的实例

		<br>

		this的情况
		1.当以函数的形式调用时，this 是window
		2.当以方法的形式调用时，谁调用方法this就是谁
		3.当以构造函数的形式调用时，this就是新创建的对象
		
		<br>
		
		创建一个Person构造函数
		在Person构造函数中，为每个对象都添加了一个sayName方法
		目前我们的方法是在构造函数内部创建的·
		也就是构造函数每执行一次就会创建一个新的sayName方法
		也就是所有实例的sayName都是唯一的，
		这样就导致了构造函数每执行一次就会创建一个新的方法
		执行一万次就会创建一万个新的方法，而这10000个方法都是一模一样的
		这是完全没有没有必要的，完全可以使所有的对象共享同一个方法


		<script type="text/javascript">
			//
			function Person(name, age, gender) {
				this.name = name;
				this.age = age;
				this.gender = gender;
				//向对象中添加一个方法
				// this.sayName = function() {
				// 	alert("大家好我是"+name);
				// 	}
			// 	this.sayName = fun;
			}
 

			//将sayName方法在全局作用域中定义
			// 将函数定义在全局作用域,污染了全局作用域的命名空间
			// 而且定义在全局作用域中也很不安全
			// function fun() {
			// 	alert("大家好我是" + this.name);
			// }
			Person.prototype.sayName = function(){
					alert("大家好我是" + this.name);
			};




// 			function Dog() {
// 
// 			}

			var per = new Person("孙悟空", 18, "男");
			var per2 = new Person("八戒", 28, "男");
			var per3 = new Person("玉兔", 16, "女");
			//per  是 Person类的实例
// 			var dog1 = new Dog();
// 
			per2.sayName();
			per.sayName();
				//使用 instanceof 可以检查一个对象是否是一个类的实例(instance是例子)
			// 语法
			// 	对象 instanceof 构造函数
			// 如果是则返回true ,否则返回false 

			// console.log(per2 instanceof Person);
 			// console.log(dog1 instanceof Dog);


			// 所有的对象都是Object的后代
			//  所以任何的对象和Object作 instanceof 检查时都会返回true
			// console.log(per2 instanceof Object)


			// console.log(per)
			// console.log(per2)
			// console.log(per3)
		</script>
	</body>
</html>
